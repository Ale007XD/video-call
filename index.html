<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>–ü—Ä—è–º–æ–π –≤–∏–¥–µ–æ–∑–≤–æ–Ω–æ–∫ WebRTC P2P QR</title>
    <style>
    body { background: #151531; color: #fff; font-family: sans-serif; margin: 0; padding: 20px; box-sizing: border-box; }
    .center { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; }
    .block { background: #23235a; margin: 1em 0; padding: 1em; border-radius: 1em; width: 100%; max-width: 390px; }
    button { font-size: 18px; margin: 1em 0; width: 100%; background: #e94560; border: none; border-radius: 8px; padding: 12px; color: #fff; cursor: pointer; }
    textarea { width: 100%; min-height: 100px; margin: 7px 0; border-radius: 6px; border: 1px solid #888; padding: 8px; resize: vertical; background: #1e1e44; color: #fff; }
    .hidden { display: none; }
    #qrcode, #qrcode2 { background:#fff; padding: 15px; border-radius: 14px; margin-top: 10px; min-height: 200px; display: flex; align-items: center; justify-content: center; }
    .error { color: #ff7785; margin: 1em 0; text-align:center; }
    .ok { color: #94ff94; }
    #localVideo { width:45%; margin-top:7px; border-radius:8px; position:absolute; right:10px; top:10px; max-width:120px; max-height:100px; z-index:2; background:#000; }
    #remoteVideo { width:100%; margin-top:7px; border-radius:9px; background:#000; }
    </style>
</head>
<body>
<div class="center"><h2>üü¢ –í–∏–¥–µ–æ–∑–≤–æ–Ω–æ–∫ –º–µ–∂–¥—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞–º–∏ (QR/WebRTC)</h2>

<div id="step1" class="block">
    <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º:</b>
    <button onclick="asCaller()">–Ø –∑–≤–æ–Ω—é ‚Äì —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
    <button onclick="asAnswer()">–ú–Ω–µ –∑–≤–æ–Ω—è—Ç ‚Äì —è –ø—Ä–∏–Ω–∏–º–∞—é –∑–≤–æ–Ω–æ–∫</button>
</div>

<div id="step2" class="block hidden">
    <b>1. –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–∏–º –∫–ª—é—á–æ–º:</b>
    <div id="qrcode" class="hidden"></div>
    <textarea id="sdpOut" readonly></textarea>
    <button onclick="copyToClipboard('sdpOut')">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
    <div id="qrwarn" class="error hidden"></div>
    <hr>
    <b>2. –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á-–æ—Ç–≤–µ—Ç –æ—Ç –≤—Ç–æ—Ä–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:</b>
    <textarea id="sdpIn" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –∫–ª—é—á-–æ—Ç–≤–µ—Ç —Å—é–¥–∞"></textarea>
    <button onclick="importRemoteDesc()">‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ</button>
    <div class="error" id="startError"></div>
</div>

<div id="step3" class="block hidden">
    <b>1. –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç –∑–≤–æ–Ω—è—â–µ–≥–æ:</b>
    <textarea id="sdpIn2" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –∫–ª—é—á-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —Å—é–¥–∞ –∏–ª–∏ –æ—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥"></textarea>
    <button onclick="importOfferDesc()">–°–æ–∑–¥–∞—Ç—å –æ—Ç–≤–µ—Ç</button>
    <div id="createWarn" class="error hidden"></div>
    <hr>
    <b>2. –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–∏–º –∫–ª—é—á–æ–º-–æ—Ç–≤–µ—Ç–æ–º:</b>
    <div id="qrcode2" class="hidden"></div>
    <textarea id="sdpOut2" readonly></textarea>
    <button onclick="copyToClipboard('sdpOut2')">üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
</div>

<div id="step4" class="block hidden">
    <div class="ok">üîó –ö–∞–Ω–∞–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –í–∏–¥–µ–æ –Ω–∏–∂–µ.</div>
    <video id="remoteVideo" autoplay playsinline></video>
    <video id="localVideo" autoplay playsinline muted></video>
    <button onclick="hangup()">‚ùå –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫</button>
</div>

<div style="text-align:center;font-size:13px;color:#ccc;margin-top:32px;">by @yourname, open source</div>
</div>

<!-- QRCode.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<script>
let pc = null;
let localStream = null;

function show(id) {
    ['step1','step2','step3','step4'].forEach(e => {
        document.getElementById(e).classList.add('hidden');
    });
    document.getElementById(id).classList.remove('hidden');
}

async function copyToClipboard(id) {
    const text = document.getElementById(id).value;
    if (!text) return;
    try {
        await navigator.clipboard.writeText(text);
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ "—Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ"
    } catch (err) {
        console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å:', err);
        // fallback (—Ä–µ–¥–∫–æ –Ω—É–∂–Ω–æ)
        const ta = document.getElementById(id);
        ta.select();
        ta.setSelectionRange(0, 99999);
        document.execCommand('copy');
    }
}

function showQRIfNeeded(sdpId, qrId, warnId) {
    const sdpText = document.getElementById(sdpId).value;
    const qrEl = document.getElementById(qrId);
    const warnEl = document.getElementById(warnId);
    if (sdpText.length <= 800) {
        qrEl.classList.remove('hidden');
        // –û—á–∏—Å—Ç–∏–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π QR
        qrEl.innerHTML = '';
        new QRCode(qrEl, { text: sdpText, width: 230, height: 230 });
        warnEl.classList.add('hidden');
    } else {
        qrEl.classList.add('hidden');
        warnEl.classList.remove('hidden');
        warnEl.innerHTML = 'SDP —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è QR-–∫–æ–¥–∞.<br>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ!';
    }
}

function hangup() {
    if (pc) {
        pc.close();
        pc = null;
    }
    if (localStream) {
        localStream.getTracks().forEach(tr => tr.stop());
        localStream = null;
    }
    document.getElementById('localVideo').srcObject = null;
    document.getElementById('remoteVideo').srcObject = null;
    show('step1');
}

// === CALLER ===
async function asCaller() {
    hangup(); // –Ω–∞ —Å–ª—É—á–∞–π –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
    show('step2');
    document.getElementById('startError').textContent = '';

    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
        document.getElementById('localVideo').srcObject = localStream;

        const iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:openrelay.metered.ca:80',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            {
                urls: 'turn:openrelay.metered.ca:443',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            }
        ];

        pc = new RTCPeerConnection({ iceServers });

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.ontrack = e => {
            document.getElementById('remoteVideo').srcObject = e.streams[0];
            show('step4');
        };

        pc.oniceconnectionstatechange = () => {
            if (pc.iceConnectionState === 'failed') {
                alert('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
                hangup();
            }
        };

        const candidates = [];
        pc.onicecandidate = async (event) => {
            if (event.candidate) {
                candidates.push(event.candidate);
            } else {
                // –í—Å–µ –∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–±—Ä–∞–Ω—ã
                const offer = pc.localDescription;
                let sdpWithCandidates = offer.sdp;
                for (const cand of candidates) {
                    sdpWithCandidates += `a=candidate:${cand.candidate}\r\n`;
                }
                const fullOffer = { type: 'offer', sdp: sdpWithCandidates };
                document.getElementById('sdpOut').value = JSON.stringify(fullOffer);
                showQRIfNeeded('sdpOut', 'qrcode', 'qrwarn');
            }
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        // –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞—á–Ω—É—Ç —Å–æ–±–∏—Ä–∞—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    } catch (e) {
        console.error(e);
        document.getElementById('startError').textContent = '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ/–º–∏–∫—Ä–æ—Ñ–æ–Ω—É';
    }
}

// === ANSWER ===
async function asAnswer() {
    hangup();
    show('step3');
    document.getElementById('createWarn').classList.add('hidden');
}

async function importOfferDesc() {
    const sdpText = document.getElementById('sdpIn2').value.trim();
    if (!sdpText) return;

    try {
        const offer = JSON.parse(sdpText);
        localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
        document.getElementById('localVideo').srcObject = localStream;

        const iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            {
                urls: 'turn:openrelay.metered.ca:80',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            }
        ];

        pc = new RTCPeerConnection({ iceServers });
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.ontrack = e => {
            document.getElementById('remoteVideo').srcObject = e.streams[0];
            show('step4');
        };

        pc.oniceconnectionstatechange = () => {
            if (pc.iceConnectionState === 'failed') {
                alert('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
                hangup();
            }
        };

        await pc.setRemoteDescription(new RTCSessionDescription(offer));

        const candidates = [];
        pc.onicecandidate = async (event) => {
            if (event.candidate) {
                candidates.push(event.candidate);
            } else {
                const answer = pc.localDescription;
                let sdpWithCandidates = answer.sdp;
                for (const cand of candidates) {
                    sdpWithCandidates += `a=candidate:${cand.candidate}\r\n`;
                }
                const fullAnswer = { type: 'answer', sdp: sdpWithCandidates };
                document.getElementById('sdpOut2').value = JSON.stringify(fullAnswer);
                showQRIfNeeded('sdpOut2', 'qrcode2', 'createWarn');
            }
        };

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

    } catch (e) {
        console.error(e);
        document.getElementById('createWarn').classList.remove('hidden');
        document.getElementById('createWarn').textContent = '–û—à–∏–±–∫–∞! –ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –∫–ª—é—á.';
    }
}

// === CALLER: —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ç–≤–µ—Ç ===
async function importRemoteDesc() {
    const sdpText = document.getElementById('sdpIn').value.trim();
    if (!sdpText) return;

    try {
        const answer = JSON.parse(sdpText);
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
    } catch (e) {
        console.error(e);
        document.getElementById('startError').textContent = '–û—à–∏–±–∫–∞! –ö–ª—é—á-–æ—Ç–≤–µ—Ç –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç.';
    }
}
</script>
</body>
</html>
